{"componentChunkName":"component---src-templates-blogs-js","path":"/blogs/swift-jwt-es256-es384-es512","webpackCompilationHash":"a23aaa782308d970cae7","result":{"data":{"blog":{"html":"<p>We have just released version 3.3 of Swift-JWT. This utilizes our new BlueECC repository to support signing and verifying of JWTs using ES256, ES384 and ES512 algorithms. In this blog, we will explain what these algorithms are and demonstrate how to use them in Swift-JWT.</p>\n<h2 id=\"elliptic-curve-digital-signature-algorithm-ecdsa\"><a href=\"#elliptic-curve-digital-signature-algorithm-ecdsa\" aria-label=\"elliptic curve digital signature algorithm ecdsa permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Elliptic Curve Digital Signature Algorithm (ECDSA)</h2>\n<p>To explain why you should use these algorithms, I’ll quote the JSON Web Algorithms specification:</p>\n<blockquote>\n<p>The Elliptic Curve Digital Signature Algorithm (ECDSA) provides for the use of Elliptic Curve Cryptography, which is able to provide equivalent security to RSA cryptography but using shorter key sizes and with greater processing speed for many operations. This means that ECDSA digital signatures will be substantially smaller in terms of length than equivalently strong RSA digital signatures.</p>\n</blockquote>\n<p>In short they are faster, use smaller keys and produce shorter signatures. For these reasons, the specification recommends elliptic curve above RSA and states that the requirement for ECDSA support will be increased in future releases.</p>\n<p>Finally, Apple requires you use ES256 as an authentication method for lots of their services, including Apple Push Notification service (APNs), MusicKit, DeviceCheck and App Store Connect API.</p>\n<hr>\n<h2 id=\"the-es256-es384-and-es512-algorithms\"><a href=\"#the-es256-es384-and-es512-algorithms\" aria-label=\"the es256 es384 and es512 algorithms permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The ES256, ES384 and ES512 Algorithms</h2>\n<p>There are currently three recognized implementations of ECDSA for JSON Web Tokens (JWT):</p>\n<ul>\n<li>ES256 – ECDSA using P-256 and SHA-256</li>\n<li>ES384 – ECDSA using P-384 and SHA-384</li>\n<li>ES512 – ECDSA using P-521 and SHA-512</li>\n</ul>\n<p>The P-XXX refers to the prime256v1, secp384r1, and secp521r1 elliptic curves. These curves generate a key pair with XXX number of private key data bits. The SHA-XXX refers to the SHA algorithm that is used to hash the plaintext prior to it being signed. Using larger keys provides more security but requires longer signatures and more processing power. We recommend ES256 for most users since it provides the same security as 3072 bit RSA key, which is considered secure beyond 2030.</p>\n<p>If you would like to know more about elliptic curve cryptography, check out our BlueECC blog post.</p>\n<hr>\n<h2 id=\"elliptic-curve-key-pair\"><a href=\"#elliptic-curve-key-pair\" aria-label=\"elliptic curve key pair permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Elliptic curve key pair</h2>\n<p>ECDSA uses asymmetric elliptic curve keys. These can be generated through Apple, OpenSSL or using BlueECC. For a p-256 curve, these keys should look something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">let</span> privateKey <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span>\"\n<span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token constant\">BEGIN</span> <span class=\"token constant\">EC</span> <span class=\"token constant\">PRIVATE</span> <span class=\"token constant\">KEY</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span>\n<span class=\"token builtin\">MHcCAQEEIJX</span><span class=\"token operator\">+</span>87WJ7Gh19sohyZnhxZeXYNOcuGv4Q<span class=\"token operator\">+</span>8MLge4UkaZoAoGCCqGSM49\n<span class=\"token builtin\">AwEHoUQDQgAEikc5m6C2xtDWeeAeT18WElO37zvFOz8p4kAlhvgIHN23XIClNESg</span>\n<span class=\"token builtin\">KVmLgSSq2asqiwdrU5YHbcHFkgdABM1SPA</span><span class=\"token operator\">==</span>\n<span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token constant\">END</span> <span class=\"token constant\">EC</span> <span class=\"token constant\">PRIVATE</span> <span class=\"token constant\">KEY</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span>\n<span class=\"token string\">\"\"</span>\"\n<span class=\"token keyword\">let</span> publicKey <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span>\"\n<span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token constant\">BEGIN</span> <span class=\"token constant\">PUBLIC</span> <span class=\"token constant\">KEY</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span>\n<span class=\"token builtin\">MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEikc5m6C2xtDWeeAeT18WElO37zvF</span>\n<span class=\"token builtin\">Oz8p4kAlhvgIHN23XIClNESgKVmLgSSq2asqiwdrU5YHbcHFkgdABM1SPA</span><span class=\"token operator\">==</span>\n<span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token constant\">END</span> <span class=\"token constant\">PUBLIC</span> <span class=\"token constant\">KEY</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span>\n<span class=\"token string\">\"\"</span>\"</code></pre></div>\n<p>The PEM format, refers to the “BEGIN”/”END” headers with some base64Encoded ASN1 data between them. If you decode the p-256 private key’s ASN1 data (e.g. using this online decoder) there are three main components of the key:</p>\n<ul>\n<li>32 bytes of private data</li>\n<li>an object identifier that specifies the elliptic curve</li>\n<li>65 bytes of public key data</li>\n</ul>\n<p>When you create a ES256/ES384/ES512 JWTSigner or JWTVerifier in Swift-JWT, it will extract the required components from the PEM string.</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">let</span> signer <span class=\"token operator\">=</span> <span class=\"token builtin\">JWTSigner</span><span class=\"token punctuation\">.</span><span class=\"token function\">es256</span><span class=\"token punctuation\">(</span>privateKey<span class=\"token punctuation\">:</span> <span class=\"token function\">Data</span><span class=\"token punctuation\">(</span>privateKey<span class=\"token punctuation\">.</span>utf8<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">let</span> verifier <span class=\"token operator\">=</span> <span class=\"token builtin\">JWTVerifier</span><span class=\"token punctuation\">.</span><span class=\"token function\">es256</span><span class=\"token punctuation\">(</span>publicKey<span class=\"token punctuation\">:</span> <span class=\"token function\">Data</span><span class=\"token punctuation\">(</span>publicKey<span class=\"token punctuation\">.</span>utf8<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<hr>\n<h2 id=\"ecdsa-signing-and-verifying\"><a href=\"#ecdsa-signing-and-verifying\" aria-label=\"ecdsa signing and verifying permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ECDSA signing and verifying</h2>\n<p>Once you have your signer and verifier, the process is exactly the same as RSA. To demonstrate this we will sign a JWT using ES256:</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">let</span> claims <span class=\"token operator\">=</span> <span class=\"token function\">ClaimsStandardJWT</span><span class=\"token punctuation\">(</span>iss<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Kitura\"</span><span class=\"token punctuation\">,</span> sub<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Joe Bloggs\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">var</span> myJWT <span class=\"token operator\">=</span> <span class=\"token function\">JWT</span><span class=\"token punctuation\">(</span>claims<span class=\"token punctuation\">:</span> claims<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> signedJWT <span class=\"token operator\">=</span> <span class=\"token keyword\">try</span> myJWT<span class=\"token punctuation\">.</span><span class=\"token function\">sign</span><span class=\"token punctuation\">(</span>using<span class=\"token punctuation\">:</span> signer<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">let</span> verified <span class=\"token operator\">=</span> <span class=\"token constant\">JWT</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">ClaimsStandardJWT</span><span class=\"token operator\">></span><span class=\"token punctuation\">.</span><span class=\"token function\">verify</span><span class=\"token punctuation\">(</span>signedJWT<span class=\"token punctuation\">,</span> using<span class=\"token punctuation\">:</span> verifier<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"JWT error: <span class=\"token interpolation\"><span class=\"token delimiter variable\">\\(</span>error<span class=\"token delimiter variable\">)</span></span>\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This will produce a boolean value of verified and a signed JWT String that is formatted:\n<code class=\"language-text\">&lt;encoded header&gt;.&lt;encoded claims&gt;.&lt;signature&gt;.</code>\nAn example signed JWT using the keys from above would be:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NiJ9.eyJpc3MiOiJraXR1cmEiLCJzdWIiOiJKb2UgQmxvZ2dzIn0._RcOxoU-3IYwFA7W81FmMEA5ON7QDB0mQ6w3HfMg9aOxKaT6ewb6WJcFdMjKggCTjBvlX5Mjr2icKkfrqTUl9A</code></pre></div>\n<p>You can inspect this JWT String using the jwt.io debugger. Select ES256, copy across the private key, public key and JWT string. The debugger will decode your header and claims, as well as verifying the signature.</p>","frontmatter":{"path":"/blogs/swift-jwt-es256-es384-es512","title":"Swift-JWT 3.3: Adding ES256, ES384, and ES512 Support","author":"Andrew Lees","date":"2019-03-12"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}